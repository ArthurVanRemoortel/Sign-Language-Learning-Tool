{% extends 'sign_language_app/base.html'%}
{% load static %}

{% block title %}
    Exercise
{% endblock %}

{% block content %}
    <div class="container is-max-desktop mt-2">
        <div class="level">
            <button class="delete is-large" id="cancelUnitButton"></button>
            <progress id="unitProgressBar" class="progress is-success ml-5" value="0" max="100"></progress>
        </div>
        <br>
        <br>



        <h1 id="gestureLabel" class="title is-1 has-text-centered ml11">
            <span class="text-wrapper">
            <span class="line line1"></span>
            <span class="letters">Hello Goodbye</span>
          </span>
        </h1>

        <div class="level">
            <div class="level-item has-text-centered">
                <figure class="image is-64x64 ml-2 mr-2">
                    <img src="{% static 'sign_language_app/images/body_location.png' %}" class="is-rounded" alt="Body location">
                </figure>
                <figure class="image is-64x64 ml-2 mr-2">
                    <img src="{% static 'sign_language_app/images/hand_shape.png' %}" class="is-rounded" alt="Hand shape">
                </figure>
            </div>
        </div>

        <div class="level camera-box" id="cameraAreaBox">
            <div class="level-item has-text-centered mt-6" id="cameraLoader">
                <div class="loader-1"></div>
            </div>
            <video class="input_video" hidden></video>
            <canvas class="output_canvas camera-canvas" width="1920px" height="1080px" style="width:100%;border-radius:6px">

            </canvas>
        </div>

        {#        <div class="notification is-danger level">#}
        {#            <div class="level-left">#}
        {#                <div class="level-item">#}
        {#                    <img class="mr-4" src="https://bulma.io/images/placeholders/48x48.png" alt="Placeholder image">#}
        {#                    <p class="title is-1">Incorrect</p>#}
        {#                </div>#}
        {#            </div>#}
        {#        </div>#}
        {#        <div class="card primary-background-color is-danger">#}
        {#            <div class="card-content">#}
        {#                <div class="content">#}
        {#                    <p class="title">#}
        {#                        Incorrect#}
        {#                    </p>#}
        {#                </div>#}
        {#            </div>#}
        {#            <footer class="card-footer">#}
        {#                <a href="#" class="card-footer-item ">Report</a>#}
        {#                <a href="#" class="card-footer-item">Skip</a>#}
        {#            </footer>#}
        {#        </div>#}

    </div>
{% endblock %}

{% block javascript %}
    <script type="module" async>
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const cameraAreaBox = document.getElementById('cameraAreaBox');
        const cameraLoader = document.getElementById('cameraLoader');
        const unitProgressBar = document.getElementById('unitProgressBar')
        const gestureLabel = document.getElementById('gestureLabel')
        const cancelUnitButton = document.getElementById('cancelUnitButton')
        const canvasCtx = canvasElement.getContext('2d');
        const recordingCutoffDelay = 1000
        const minRecordingSize = 1000

        let gestureStart = null
        let gestureEnd = null

        let left_landmarks = {}
        let right_landmarks = {}
        let missingHandsTime = null

        let cameraLoaded = false

        let gesture_list = [
            {
                "word": "United States of America"
            },
            {
                "word": "Word 2"
            },
            {
                "word": "Word 3"
            },
            {
                "word": "Word 4"
            },
        ]
        let current_gesture_i = 0
        let current_gesture = null

        unitProgressBar.max = gesture_list.length
        resetRecording()
        loadGesture()
        loadCamera()

        cancelUnitButton.addEventListener("click", function() { triggerAnim(false); } )

        function loadGesture() {
            updateProgressBar()
            if (current_gesture_i >= gesture_list.length)
                return
            let gesture = gesture_list[current_gesture_i]
            current_gesture =  gesture
            animateGestureTitle(gesture['word'])
        }

        function updateProgressBar(){
            unitProgressBar.value = current_gesture_i
        }

        function triggerAnim(correct) {
            console.log('triggerAnim', correct)
            if (correct){
                $(cameraAreaBox).addClass('feedback-pulse-correct')
            } else {
                $(cameraAreaBox).addClass('feedback-pulse-incorrect')
            }
        }

        $(cameraAreaBox).on('animationend', function(){
            $(cameraAreaBox).removeClass('feedback-pulse-correct');
            $(cameraAreaBox).removeClass('feedback-pulse-incorrect');
        });

        function veryfiUserInput(data){
            let csrf_token = '{{ csrf_token }}';
            $.ajax({
                url: 'http://localhost:8000/api/test',
                data: JSON.stringify(data),
                headers: {'X-CSRFToken': csrf_token},
                contentType: "application/json",
                dataType: "json",
                processData: false,
                type: 'POST',
                success: function(data) {
                    console.log(data)
                    if (data.correct){
                        triggerAnim(true)
                        current_gesture_i += 1
                        loadGesture()
                    } else {
                        triggerAnim(false)
                    }
                },
                error: function(err) { console.log(err); },
                beforeSend: function (xhr) {
                },
            });
        }

        function animateGestureTitle(new_word){
            var textWrapper = document.querySelector('.ml11 .letters');

            textWrapper.textContent = new_word
            textWrapper.innerHTML = textWrapper.textContent.replace(/([^\x00-\x80]|\w)/g, "<span class='letter'>$&</span>");
            anime.timeline({loop: false})
                .add({
                    targets: '.ml11 .line',
                    scaleY: [0,1],
                    opacity: [0.5,1],
                    easing: "easeOutExpo",
                    duration: 700
                })
                .add({
                    targets: '.ml11 .line',
                    translateX: [0, document.querySelector('.ml11 .letters').getBoundingClientRect().width + 10],
                    easing: "easeOutExpo",
                    duration: 700,
                    delay: 100
                }).add({
                targets: '.ml11 .letter',
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 600,
                offset: '-=775',
                delay: (el, i) => 34 * (i+1)
            }).add({
                targets: '.line',
                opacity: 0,
                duration: 1000,
                easing: "easeOutExpo",
                delay: 0
            });
        }


        function beginRecording() {
            console.log("Beginning gesture recording...")
            gestureStart = performance.now()
        }

        function resetRecording(){
            gestureStart = null
            gestureEnd = null
            missingHandsTime = null
            for(let landmark_id = 1; landmark_id <= 21; landmark_id++){
                left_landmarks[landmark_id] = []
                right_landmarks[landmark_id] = []
            }
        }

        function endRecording() {
            // TODO: Only end recording if no hands were detected for multiple frames.
            if (performance.now() - gestureStart < recordingCutoffDelay + minRecordingSize){
                console.log("This recording was to short. This was probably an accident.")
                resetRecording()
                return
            }
            gestureEnd = performance.now()
            console.log("Ended gesture recording")

            var data = {
                left_landmarks: left_landmarks,
                right_landmarks: right_landmarks,
                gesture_id: current_gesture
            };

            veryfiUserInput(data)
            resetRecording()
        }

        const zip = (a, b) => a.map((k, i) => [k, b[i]]);

        function flip_handedness(string){
            if (string === "Left")
                return "Right"
            return "Left"
        }



        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.translate(canvasElement.width, 0);
            canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks) {
                if (results.multiHandLandmarks.length > 0) {
                    missingHandsTime =  null
                    if (gestureStart == null)
                        beginRecording()
                    const zipped_landmarks = zip(results.multiHandLandmarks, results.multiHandedness);
                    for (const landmarks_handed of zipped_landmarks) {
                        {#console.log(landmarks_handed)#}
                        let landmarks = landmarks_handed[0]
                        let handedness = flip_handedness(landmarks_handed[1].label)
                        for(let landmark_id = 1; landmark_id <= landmarks.length; landmark_id++){
                            if (handedness === 'Left'){
                                left_landmarks[landmark_id].push(landmarks[landmark_id])
                                right_landmarks[landmark_id].push(null)
                            } else if (handedness === "Right"){
                                right_landmarks[landmark_id].push(landmarks[landmark_id])
                                left_landmarks[landmark_id].push(null)
                            }
                        }
                        let color = '#00FF00';
                        if (handedness === "Right")
                            color = '#518dce';
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                            {color: color, lineWidth: 5});
                        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2});
                    }
                } else {
                    // No hands detected.
                    if (gestureStart != null) {
                        if (missingHandsTime == null)
                            missingHandsTime = performance.now()
                        if (performance.now() - missingHandsTime >= recordingCutoffDelay)
                            endRecording()
                    }
                }

            }
            canvasCtx.restore();
        }

        function loadCamera(){
            const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.8,
                minTrackingConfidence: 0.8
            });
            hands.onResults(onResults);


            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                    if (!cameraLoaded){
                        console.log("done")
                        cameraLoaded = true
                        $(cameraLoader).remove()
                    }

                },
                width: 1280,
                height: 720
            });
            camera.start()
        }

    </script>
{% endblock %}